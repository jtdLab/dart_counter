// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'single_training_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SingleTrainingEventTearOff {
  const _$SingleTrainingEventTearOff();

  _SingleTrainingModeChanged modeChanged({required Mode newMode}) {
    return _SingleTrainingModeChanged(
      newMode: newMode,
    );
  }

  _SingleTrainingPerformPressed performPressed() {
    return const _SingleTrainingPerformPressed();
  }

  _SingleTrainingUndoPressed undoPressed() {
    return const _SingleTrainingUndoPressed();
  }

  _SingleTrainingSingleHitPressed singleHitPressed() {
    return const _SingleTrainingSingleHitPressed();
  }

  _SingleTrainingDoubleHitPressed doubleHitPressed() {
    return const _SingleTrainingDoubleHitPressed();
  }

  _SingleTrainingTripleHitPressed tripleHitPressed() {
    return const _SingleTrainingTripleHitPressed();
  }

  _SingleTrainingMissHitPressed missHitPressed() {
    return const _SingleTrainingMissHitPressed();
  }
}

/// @nodoc
const $SingleTrainingEvent = _$SingleTrainingEventTearOff();

/// @nodoc
mixin _$SingleTrainingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SingleTrainingEventCopyWith<$Res> {
  factory $SingleTrainingEventCopyWith(
          SingleTrainingEvent value, $Res Function(SingleTrainingEvent) then) =
      _$SingleTrainingEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SingleTrainingEventCopyWithImpl<$Res>
    implements $SingleTrainingEventCopyWith<$Res> {
  _$SingleTrainingEventCopyWithImpl(this._value, this._then);

  final SingleTrainingEvent _value;
  // ignore: unused_field
  final $Res Function(SingleTrainingEvent) _then;
}

/// @nodoc
abstract class _$SingleTrainingModeChangedCopyWith<$Res> {
  factory _$SingleTrainingModeChangedCopyWith(_SingleTrainingModeChanged value,
          $Res Function(_SingleTrainingModeChanged) then) =
      __$SingleTrainingModeChangedCopyWithImpl<$Res>;
  $Res call({Mode newMode});
}

/// @nodoc
class __$SingleTrainingModeChangedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingModeChangedCopyWith<$Res> {
  __$SingleTrainingModeChangedCopyWithImpl(_SingleTrainingModeChanged _value,
      $Res Function(_SingleTrainingModeChanged) _then)
      : super(_value, (v) => _then(v as _SingleTrainingModeChanged));

  @override
  _SingleTrainingModeChanged get _value =>
      super._value as _SingleTrainingModeChanged;

  @override
  $Res call({
    Object? newMode = freezed,
  }) {
    return _then(_SingleTrainingModeChanged(
      newMode: newMode == freezed
          ? _value.newMode
          : newMode // ignore: cast_nullable_to_non_nullable
              as Mode,
    ));
  }
}

/// @nodoc

class _$_SingleTrainingModeChanged implements _SingleTrainingModeChanged {
  const _$_SingleTrainingModeChanged({required this.newMode});

  @override
  final Mode newMode;

  @override
  String toString() {
    return 'SingleTrainingEvent.modeChanged(newMode: $newMode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingModeChanged &&
            (identical(other.newMode, newMode) || other.newMode == newMode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newMode);

  @JsonKey(ignore: true)
  @override
  _$SingleTrainingModeChangedCopyWith<_SingleTrainingModeChanged>
      get copyWith =>
          __$SingleTrainingModeChangedCopyWithImpl<_SingleTrainingModeChanged>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return modeChanged(newMode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return modeChanged?.call(newMode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (modeChanged != null) {
      return modeChanged(newMode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return modeChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return modeChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (modeChanged != null) {
      return modeChanged(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingModeChanged implements SingleTrainingEvent {
  const factory _SingleTrainingModeChanged({required Mode newMode}) =
      _$_SingleTrainingModeChanged;

  Mode get newMode;
  @JsonKey(ignore: true)
  _$SingleTrainingModeChangedCopyWith<_SingleTrainingModeChanged>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SingleTrainingPerformPressedCopyWith<$Res> {
  factory _$SingleTrainingPerformPressedCopyWith(
          _SingleTrainingPerformPressed value,
          $Res Function(_SingleTrainingPerformPressed) then) =
      __$SingleTrainingPerformPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingPerformPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingPerformPressedCopyWith<$Res> {
  __$SingleTrainingPerformPressedCopyWithImpl(
      _SingleTrainingPerformPressed _value,
      $Res Function(_SingleTrainingPerformPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingPerformPressed));

  @override
  _SingleTrainingPerformPressed get _value =>
      super._value as _SingleTrainingPerformPressed;
}

/// @nodoc

class _$_SingleTrainingPerformPressed implements _SingleTrainingPerformPressed {
  const _$_SingleTrainingPerformPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.performPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingPerformPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return performPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return performPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (performPressed != null) {
      return performPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return performPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return performPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (performPressed != null) {
      return performPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingPerformPressed implements SingleTrainingEvent {
  const factory _SingleTrainingPerformPressed() =
      _$_SingleTrainingPerformPressed;
}

/// @nodoc
abstract class _$SingleTrainingUndoPressedCopyWith<$Res> {
  factory _$SingleTrainingUndoPressedCopyWith(_SingleTrainingUndoPressed value,
          $Res Function(_SingleTrainingUndoPressed) then) =
      __$SingleTrainingUndoPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingUndoPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingUndoPressedCopyWith<$Res> {
  __$SingleTrainingUndoPressedCopyWithImpl(_SingleTrainingUndoPressed _value,
      $Res Function(_SingleTrainingUndoPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingUndoPressed));

  @override
  _SingleTrainingUndoPressed get _value =>
      super._value as _SingleTrainingUndoPressed;
}

/// @nodoc

class _$_SingleTrainingUndoPressed implements _SingleTrainingUndoPressed {
  const _$_SingleTrainingUndoPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.undoPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingUndoPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return undoPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return undoPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (undoPressed != null) {
      return undoPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return undoPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return undoPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (undoPressed != null) {
      return undoPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingUndoPressed implements SingleTrainingEvent {
  const factory _SingleTrainingUndoPressed() = _$_SingleTrainingUndoPressed;
}

/// @nodoc
abstract class _$SingleTrainingSingleHitPressedCopyWith<$Res> {
  factory _$SingleTrainingSingleHitPressedCopyWith(
          _SingleTrainingSingleHitPressed value,
          $Res Function(_SingleTrainingSingleHitPressed) then) =
      __$SingleTrainingSingleHitPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingSingleHitPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingSingleHitPressedCopyWith<$Res> {
  __$SingleTrainingSingleHitPressedCopyWithImpl(
      _SingleTrainingSingleHitPressed _value,
      $Res Function(_SingleTrainingSingleHitPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingSingleHitPressed));

  @override
  _SingleTrainingSingleHitPressed get _value =>
      super._value as _SingleTrainingSingleHitPressed;
}

/// @nodoc

class _$_SingleTrainingSingleHitPressed
    implements _SingleTrainingSingleHitPressed {
  const _$_SingleTrainingSingleHitPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.singleHitPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingSingleHitPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return singleHitPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return singleHitPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (singleHitPressed != null) {
      return singleHitPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return singleHitPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return singleHitPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (singleHitPressed != null) {
      return singleHitPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingSingleHitPressed implements SingleTrainingEvent {
  const factory _SingleTrainingSingleHitPressed() =
      _$_SingleTrainingSingleHitPressed;
}

/// @nodoc
abstract class _$SingleTrainingDoubleHitPressedCopyWith<$Res> {
  factory _$SingleTrainingDoubleHitPressedCopyWith(
          _SingleTrainingDoubleHitPressed value,
          $Res Function(_SingleTrainingDoubleHitPressed) then) =
      __$SingleTrainingDoubleHitPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingDoubleHitPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingDoubleHitPressedCopyWith<$Res> {
  __$SingleTrainingDoubleHitPressedCopyWithImpl(
      _SingleTrainingDoubleHitPressed _value,
      $Res Function(_SingleTrainingDoubleHitPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingDoubleHitPressed));

  @override
  _SingleTrainingDoubleHitPressed get _value =>
      super._value as _SingleTrainingDoubleHitPressed;
}

/// @nodoc

class _$_SingleTrainingDoubleHitPressed
    implements _SingleTrainingDoubleHitPressed {
  const _$_SingleTrainingDoubleHitPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.doubleHitPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingDoubleHitPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return doubleHitPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return doubleHitPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (doubleHitPressed != null) {
      return doubleHitPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return doubleHitPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return doubleHitPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (doubleHitPressed != null) {
      return doubleHitPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingDoubleHitPressed implements SingleTrainingEvent {
  const factory _SingleTrainingDoubleHitPressed() =
      _$_SingleTrainingDoubleHitPressed;
}

/// @nodoc
abstract class _$SingleTrainingTripleHitPressedCopyWith<$Res> {
  factory _$SingleTrainingTripleHitPressedCopyWith(
          _SingleTrainingTripleHitPressed value,
          $Res Function(_SingleTrainingTripleHitPressed) then) =
      __$SingleTrainingTripleHitPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingTripleHitPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingTripleHitPressedCopyWith<$Res> {
  __$SingleTrainingTripleHitPressedCopyWithImpl(
      _SingleTrainingTripleHitPressed _value,
      $Res Function(_SingleTrainingTripleHitPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingTripleHitPressed));

  @override
  _SingleTrainingTripleHitPressed get _value =>
      super._value as _SingleTrainingTripleHitPressed;
}

/// @nodoc

class _$_SingleTrainingTripleHitPressed
    implements _SingleTrainingTripleHitPressed {
  const _$_SingleTrainingTripleHitPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.tripleHitPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingTripleHitPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return tripleHitPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return tripleHitPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (tripleHitPressed != null) {
      return tripleHitPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return tripleHitPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return tripleHitPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (tripleHitPressed != null) {
      return tripleHitPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingTripleHitPressed implements SingleTrainingEvent {
  const factory _SingleTrainingTripleHitPressed() =
      _$_SingleTrainingTripleHitPressed;
}

/// @nodoc
abstract class _$SingleTrainingMissHitPressedCopyWith<$Res> {
  factory _$SingleTrainingMissHitPressedCopyWith(
          _SingleTrainingMissHitPressed value,
          $Res Function(_SingleTrainingMissHitPressed) then) =
      __$SingleTrainingMissHitPressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SingleTrainingMissHitPressedCopyWithImpl<$Res>
    extends _$SingleTrainingEventCopyWithImpl<$Res>
    implements _$SingleTrainingMissHitPressedCopyWith<$Res> {
  __$SingleTrainingMissHitPressedCopyWithImpl(
      _SingleTrainingMissHitPressed _value,
      $Res Function(_SingleTrainingMissHitPressed) _then)
      : super(_value, (v) => _then(v as _SingleTrainingMissHitPressed));

  @override
  _SingleTrainingMissHitPressed get _value =>
      super._value as _SingleTrainingMissHitPressed;
}

/// @nodoc

class _$_SingleTrainingMissHitPressed implements _SingleTrainingMissHitPressed {
  const _$_SingleTrainingMissHitPressed();

  @override
  String toString() {
    return 'SingleTrainingEvent.missHitPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingMissHitPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Mode newMode) modeChanged,
    required TResult Function() performPressed,
    required TResult Function() undoPressed,
    required TResult Function() singleHitPressed,
    required TResult Function() doubleHitPressed,
    required TResult Function() tripleHitPressed,
    required TResult Function() missHitPressed,
  }) {
    return missHitPressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
  }) {
    return missHitPressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Mode newMode)? modeChanged,
    TResult Function()? performPressed,
    TResult Function()? undoPressed,
    TResult Function()? singleHitPressed,
    TResult Function()? doubleHitPressed,
    TResult Function()? tripleHitPressed,
    TResult Function()? missHitPressed,
    required TResult orElse(),
  }) {
    if (missHitPressed != null) {
      return missHitPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingModeChanged value) modeChanged,
    required TResult Function(_SingleTrainingPerformPressed value)
        performPressed,
    required TResult Function(_SingleTrainingUndoPressed value) undoPressed,
    required TResult Function(_SingleTrainingSingleHitPressed value)
        singleHitPressed,
    required TResult Function(_SingleTrainingDoubleHitPressed value)
        doubleHitPressed,
    required TResult Function(_SingleTrainingTripleHitPressed value)
        tripleHitPressed,
    required TResult Function(_SingleTrainingMissHitPressed value)
        missHitPressed,
  }) {
    return missHitPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
  }) {
    return missHitPressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingModeChanged value)? modeChanged,
    TResult Function(_SingleTrainingPerformPressed value)? performPressed,
    TResult Function(_SingleTrainingUndoPressed value)? undoPressed,
    TResult Function(_SingleTrainingSingleHitPressed value)? singleHitPressed,
    TResult Function(_SingleTrainingDoubleHitPressed value)? doubleHitPressed,
    TResult Function(_SingleTrainingTripleHitPressed value)? tripleHitPressed,
    TResult Function(_SingleTrainingMissHitPressed value)? missHitPressed,
    required TResult orElse(),
  }) {
    if (missHitPressed != null) {
      return missHitPressed(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingMissHitPressed implements SingleTrainingEvent {
  const factory _SingleTrainingMissHitPressed() =
      _$_SingleTrainingMissHitPressed;
}

/// @nodoc
class _$SingleTrainingStateTearOff {
  const _$SingleTrainingStateTearOff();

  _SingleTrainingInitial initial(
      {required KtList<Hit> hits, required Mode mode}) {
    return _SingleTrainingInitial(
      hits: hits,
      mode: mode,
    );
  }
}

/// @nodoc
const $SingleTrainingState = _$SingleTrainingStateTearOff();

/// @nodoc
mixin _$SingleTrainingState {
  KtList<Hit> get hits => throw _privateConstructorUsedError;
  Mode get mode => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(KtList<Hit> hits, Mode mode) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(KtList<Hit> hits, Mode mode)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(KtList<Hit> hits, Mode mode)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingInitial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingInitial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingInitial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SingleTrainingStateCopyWith<SingleTrainingState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SingleTrainingStateCopyWith<$Res> {
  factory $SingleTrainingStateCopyWith(
          SingleTrainingState value, $Res Function(SingleTrainingState) then) =
      _$SingleTrainingStateCopyWithImpl<$Res>;
  $Res call({KtList<Hit> hits, Mode mode});
}

/// @nodoc
class _$SingleTrainingStateCopyWithImpl<$Res>
    implements $SingleTrainingStateCopyWith<$Res> {
  _$SingleTrainingStateCopyWithImpl(this._value, this._then);

  final SingleTrainingState _value;
  // ignore: unused_field
  final $Res Function(SingleTrainingState) _then;

  @override
  $Res call({
    Object? hits = freezed,
    Object? mode = freezed,
  }) {
    return _then(_value.copyWith(
      hits: hits == freezed
          ? _value.hits
          : hits // ignore: cast_nullable_to_non_nullable
              as KtList<Hit>,
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
    ));
  }
}

/// @nodoc
abstract class _$SingleTrainingInitialCopyWith<$Res>
    implements $SingleTrainingStateCopyWith<$Res> {
  factory _$SingleTrainingInitialCopyWith(_SingleTrainingInitial value,
          $Res Function(_SingleTrainingInitial) then) =
      __$SingleTrainingInitialCopyWithImpl<$Res>;
  @override
  $Res call({KtList<Hit> hits, Mode mode});
}

/// @nodoc
class __$SingleTrainingInitialCopyWithImpl<$Res>
    extends _$SingleTrainingStateCopyWithImpl<$Res>
    implements _$SingleTrainingInitialCopyWith<$Res> {
  __$SingleTrainingInitialCopyWithImpl(_SingleTrainingInitial _value,
      $Res Function(_SingleTrainingInitial) _then)
      : super(_value, (v) => _then(v as _SingleTrainingInitial));

  @override
  _SingleTrainingInitial get _value => super._value as _SingleTrainingInitial;

  @override
  $Res call({
    Object? hits = freezed,
    Object? mode = freezed,
  }) {
    return _then(_SingleTrainingInitial(
      hits: hits == freezed
          ? _value.hits
          : hits // ignore: cast_nullable_to_non_nullable
              as KtList<Hit>,
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
    ));
  }
}

/// @nodoc

class _$_SingleTrainingInitial implements _SingleTrainingInitial {
  const _$_SingleTrainingInitial({required this.hits, required this.mode});

  @override
  final KtList<Hit> hits;
  @override
  final Mode mode;

  @override
  String toString() {
    return 'SingleTrainingState.initial(hits: $hits, mode: $mode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SingleTrainingInitial &&
            (identical(other.hits, hits) || other.hits == hits) &&
            (identical(other.mode, mode) || other.mode == mode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hits, mode);

  @JsonKey(ignore: true)
  @override
  _$SingleTrainingInitialCopyWith<_SingleTrainingInitial> get copyWith =>
      __$SingleTrainingInitialCopyWithImpl<_SingleTrainingInitial>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(KtList<Hit> hits, Mode mode) initial,
  }) {
    return initial(hits, mode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(KtList<Hit> hits, Mode mode)? initial,
  }) {
    return initial?.call(hits, mode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(KtList<Hit> hits, Mode mode)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(hits, mode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SingleTrainingInitial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SingleTrainingInitial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SingleTrainingInitial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _SingleTrainingInitial implements SingleTrainingState {
  const factory _SingleTrainingInitial(
      {required KtList<Hit> hits,
      required Mode mode}) = _$_SingleTrainingInitial;

  @override
  KtList<Hit> get hits;
  @override
  Mode get mode;
  @override
  @JsonKey(ignore: true)
  _$SingleTrainingInitialCopyWith<_SingleTrainingInitial> get copyWith =>
      throw _privateConstructorUsedError;
}
